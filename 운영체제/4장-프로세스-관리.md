## [프로세스 관리 #1](https://core.ewha.ac.kr/publicview/C0101020140321144554159683?vmode=f)

## **프로세스 생성 (Process Creation)**

### 부모 프로세스가 자식 프로세스를 생성

- 이 때 복제 생성하여 프로세스의 주소 공간을 그대로 복사하여 자식 프로세스를 생성함.
- 프로세스 트리(계층구조)를 형성
- 프로세스는 자원을 필요로 한다
    - 운영체제로부터 자원을 할당 받음
    - 자원 공유
        - 부모와 자식이 모든 자원을 공유
        - 일부를 공유하는 모델
        - 전혀 공유하지 않는 모델
            - 원칙적으로 별개의 프로세스이기 때문에 공유하지 않음
            - 하지만 리눅스나 좀 더 효율적인 운영체제에서는 일단 카피하지 않고 주소공간을 공유함.
            - 부모와 자식의 프로세스 내용이 달라질 경우에 그제서야 공유하던 메모리 공간을 카피해서 자식이 갇게된다.(**Copy-on-write 기법(COW)**)
            

### 프로세스가 실행될 때의 모델 종류(Excution)

- 부모와 자식은 공존하면서 수행되는 모델
- 자식이 종료될 때까지 부모가 기다리는 모델(즉 부모 프로세스는 멈춰있는 상태)

### 주소 공간은 어떻게 처리가 될까?

- 자식은 부모의 공간을 복사함(binary and OS data)
- 자식은 복사 공간에 새로운 프로그램을 올린다.
- 유닉스의 예
    - **`fork()`** system call이 새로운 프로세스를 생성
        - 부모를 그대로 복사(OS data except PID + binary)
        - 주소공간을 할당
    - fork 다음에 이어지는 **`exec()`** system call 을 통해 새로운 프로그램을 메모리에 올림
    - 즉 결국 운영체제는 부모 프로세스가 요청한대로 자식 프로세스를 형성함

## **프로세스 종료 (Process Termination)**

### 자발적인 프로세스 종료

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다 (**`exit`** system call을 명시)
    - 자식이 부모에게 output data를 보냄(via **`Wait`** system call)  (항상 자식이 먼저 종료되야함)
    - 프로세스의 각종 자원들이 운영체제에게 반납된다

### 비 자발적인 프로세스 종료

- 부모 프로세스가 자식의 수행을 종료시킴(**`abort`**)
    - 자식이 할당 자원의 한계치를 넘어설 경우
    - 자식에게 할당된 태스크가 더 이상 필요하지 않을 때
    - 부모가 종료(**`exit`**)되는 경우
        - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되지 않도록 한다
        - 단계적인 종료 절차를 밟는다

## [프로세스 관리 #2](https://core.ewha.ac.kr/publicview/C0101020140325134428879622?vmode=f)

## 프로세스와 관련한 system call

### fork()

- 어떤 프로그램을 복제하는 역할을 수행

```c
int main()
{
	int pid;
	pid = fork();
	if (pid == 0){
		printf("\n Hello, I am child! \n ");
		}
	else if (pid > 0) {
		printf("\n Hello, I am parent! \n ");
		}
}
```

- fork() 함수를 통해 새로운 프로세스를 만들어 달라는 system call을 운영체제에 요청함
- 생성된 자식 프로세스는 메인함수의 첫 부분에서 실행 되는게 아니라 fork()를 실행한 그 이후부터 실행이 된다.(즉 부모의 문맥을 그대로 복사해서 실행됨)
- 근데 이렇게 되면 누가 부모인지 파악할 수가 없어지게 된다.
    - 그래서 fork()를 하면 fork()하면 return이 다르다.
    - 자식은 return 값. 즉 위 코드에서 pid가 0이 되고, 부모는 return 값으로 양수가 된다
- 이 결과값으로 부모와 자식이 하는 일을 다르게 할 수 있다.

### exec()

- 어떤 프로그램을 새로운 프로세스로 태어나게 하는 역할을 수행

```c
int main()
{
	int pid;
	pid = fork();
	if (pid == 0){
		printf("\n Hello, I am child! Now I'll run date \n ");
		execlp("/bin/date", "/bin/date", (char*)0);
		}
	else if (pid > 0) {
		printf("\n Hello, I am parent! \n ");
		}
}
```

- 일단 fork()를 해서 자식 프로세스 생성
- execlp()가 exec() system call 을 운영체제에 요청함
- exec()이 실행되면 date의 main함수로 덮어 씌워져서 실행이 된다.
- 즉 새로운 프로그램으로 재탄생 시키는 역할
- exec() 이후 코드는 더 이상 쓸 수 없는 코드가 된다.
    
    ```c
    int main()
    {
    		printf("\n 1 \n ");
    		execlp("/bin/date", "/bin/date", (char*)0);
    		printf("\n 2 \n ");
    }
    
    출력
    1
    ```
    

### wait()

- 프로세스 A가 wait() system call을 호출하면, 커널에서 child가 종료될 때까지 프로세스 A를 sleep 시킨다.(block 상태)
- Child process가 종료되면 프로세스 A를 깨운다(ready상태)

### exit()

- 자발적 종료
    - 마지막 statement 수행 후 exit() 시스템 콜을 통해 프로그램에 명시적으로 적어주지 않아도  main 함수가 리턴되는 위치에 컴파일러가 넣어줌
- 비자발적 종료
    - 부모 프로세스가 자식 프로세를 강제 종료시킴
        - 자식 프로세스가 한계치를 넘는 자원 요청 할 경우
        - 자식에게 할당된 태스크가 더 이상 필요하지 않을 경우
    - 키보드로 kill 또는 break 등을 입력한 경우
    - 부모 프로세스가 종료되는 경우
        - 부모프로세스는 자식 프로세스가 먼저 종료되야 종료 될 수 있다.

### 프로세스 간 협력

-

### Message Passing

-

### Interprocess communication

-

### CPU and I/O Bursts in Program Execution

-

### CPU-burst Time의 분포

-

### 프로세스의 특성 분류

-

### CPU Scheduler & Dispatcher

-
